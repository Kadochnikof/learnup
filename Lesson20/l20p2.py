"""Алгоритм 1"""
def unique_list(data):
    for i in range(len(data)):
        if data[i] in data[i+1]:
            return False
    return True
"""Cложность по времени алгоритма unique_list составляет O(n^2). Это связано с тем, что
алгоритм сравнивает каждый элемент списка с каждым последующим элементом, что приводит к квадратичной 
скорости роста.

В худшем случае входными данными для этого алгоритма будет список со всеми одинаковыми элементами, поскольку алгоритму 
придется проверять каждый элемент на соответствие каждому другому элементу. 
В лучшем случае входными данными будет список со всеми уникальными элементами, так как алгоритму потребуется 
только один раз сверить каждый элемент с его последующим элементом.

Сложность задачи возрастает с увеличением размера входного списка. По мере роста длины списка количество сравнений, 
которые должен выполнить алгоритм, увеличивается в геометрической прогрессии, что приводит к увеличению времени 
выполнения."""




"""Алгоритм 2"""
def local_max_counter(data):
    c = 0
    for i in range(1, len(data) - 1):
        if data[i] > data[i - 1] and data[i] > data[i + 1]:
            c += 1
    return c
"""Cложность по времени алгоритма local_max_counter равна O(n). Это связано с тем, что алгоритм выполняет итерацию по 
каждому элементу списка один раз и выполняет операции над каждым элементом.

В худшем случае входными данными для этого алгоритма будет список, в котором все элементы одинаковы, так как не будет 
локальных максимумов для подсчета. 
В лучшем случае входными данными для этого алгоритма будет список только с одним локальным максимумом, так как алгоритму 
потребуется только одно сравнение, чтобы найти его.

Сложность задачи существенно не зависит от размера входного списка, так как алгоритму нужно проверить каждый элемент 
только один раз. Однако увеличение размера входного списка приводит к большему количеству и большему времени выполнения"""




"""Алгоритм 3"""
def bubbleSort(data):
    n = len(data)
    swapped = False
    for i in range(n - 1):
        for j in range(0, n - i - 1):
            if data[j] > data[j + 1]:
                swapped = True
                data[j], data[j + 1] = data[j + 1], data[j]
        if not swapped:
            return
"""Cложность по времени алгоритма пузырьковой сортировки составляет O(n^2). Это связано с тем, что алгоритм несколько раз сравнивает соседние элементы списка, что приводит к квадратичной скорости роста.

В худшем случае входными данными для этого алгоритма будет список, отсортированный в обратном порядке. 
В лучшем случае входными данными для этого алгоритма будет список, который уже отсортирован.

Сложность задачи возрастает с увеличением размера входного списка. По мере роста длины списка количество сравнений и перестановок, которые должен сделать алгоритм, увеличивается, что приводит к увеличению времени выполнения."""